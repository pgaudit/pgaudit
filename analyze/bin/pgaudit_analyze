#!/usr/bin/perl
####################################################################################################################################
# pgaudit_analyze - Log analyzer for pgaudit
####################################################################################################################################

####################################################################################################################################
# Perl includes
####################################################################################################################################
use strict;
use warnings FATAL => qw(all);
use Carp qw(confess);

use DBI;
use File::Basename qw(dirname);
#use Getopt::Long qw(GetOptions);

use lib dirname($0) . '/../lib';
use PgAudit::CSV;

####################################################################################################################################
# Handle die as a confess instead to get more detailed error information
####################################################################################################################################
$SIG{__DIE__} = sub { Carp::confess @_ };

####################################################################################################################################
# Connect to Postgres
####################################################################################################################################
my $hDb = DBI->connect('dbi:Pg:dbname=pgaudit;port=5432', 'vagrant', undef, {AutoCommit => 0, RaiseError => 1});

my $hSqlSessionInsert = $hDb->prepare(
    "insert into audit_log.session (user_name, process_id, session_key, session_start_time, database_name,\n" .
    "                               connection_from, state)\n" .
    "                       values (?, ?, ?, ?, ?, ?, ?)\n" .
    "                    returning id");

my $hSqlSessionSelect = $hDb->prepare(
    "select id,\n" .
    "       user_name,\n" .
    "       database_name,\n" .
    "       connection_from,\n" .
    "       state\n" .
    " from audit_log.session\n" .
    " where process_id = ?::int\n" .
    "   and session_key = ?\n" .
    "   and session_start_time = ?::timestamp with time zone");

my $hSqlSessionUpdate = $hDb->prepare(
    "update audit_log.session\n" .
    "   set user_name = ?,\n" .
    "       database_name = ?,\n" .
    "       connection_from = ?,\n" .
    "       state = ?\n" .
    " where id = ?");

####################################################################################################################################
# Define column positions of log and audit data
####################################################################################################################################
use constant
{
    # Session unique fields
    LOG_FIELD_LOG_TIME                  => 0,
    LOG_FIELD_USER_NAME                 => 1,
    LOG_FIELD_DATABASE_NAME             => 2,
    LOG_FIELD_PROCESS_ID                => 3,
    LOG_FIELD_CONNECTION_FROM           => 4,
    LOG_FIELD_SESSION_ID                => 5,
    LOG_FIELD_SESSION_START_TIME        => 8,

    # Session unique fields
    LOG_FIELD_SESSION_LINE_NUM          => 6,
    LOG_FIELD_COMMAND_TAG               => 7,
    LOG_FIELD_VIRTUAL_TRANSACTION_ID    => 9,
    LOG_FIELD_TRANSACTION_ID            => 10,
    LOG_FIELD_ERROR_SEVERITY            => 11,
    LOG_FIELD_SQL_STATE_CODE            => 12,
    LOG_FIELD_MESSAGE                   => 13,
    LOG_FIELD_DETAIL                    => 14,
    LOG_FIELD_HINT                      => 15,
    LOG_FIELD_INTERNAL_QUERY            => 16,
    LOG_FIELD_INTERNAL_QUERY_POS        => 17,
    LOG_FIELD_CONTEXT                   => 18,
    LOG_FIELD_QUERY                     => 19,
    LOG_FIELD_QUERY_POS                 => 20,
    LOG_FIELD_LOCATION                  => 21,
    LOG_FIELD_APPLICATION_NAME          => 22
};

use constant
{
    AUDIT_FIELD_AUDIT_TYPE => 0
};

use constant
{
    COMMAND_TAG_AUTHENTICATION  => 'authentication'
};

use constant
{
    ERROR_SEVERITY_FATAL  => 'FATAL'
};

use constant
{
    STATE_OK    => 'ok',
    STATE_ERROR => 'error'
};

####################################################################################################################################
# sessionGet
####################################################################################################################################
my %oSessionHash;

sub sessionGet
{
    my $strUserName = shift;
    my $strProcessId = shift;
    my $strSessionId = shift;
    my $strSessionStartTime = shift;
    my $strDatabaseName = shift;
    my $strConnectionFrom = shift;
    my $strCommandTag = shift;
    my $strErrorSeverity = shift;

    # Set user name to a default if not defined yet
    if (!defined($strUserName))
    {
        $strUserName = '[postgres]';
    }

    # Set database name to a default if not defined yet
    if (!defined($strDatabaseName))
    {
        $strDatabaseName = '[none]';
    }

    # Set connection from to a default if not defined yet
    if (!defined($strConnectionFrom))
    {
        $strConnectionFrom = '[unknown]';
    }

    # Set state to a default if not defined yet
    my $strState;

    if (defined($strCommandTag) && $strCommandTag eq COMMAND_TAG_AUTHENTICATION &&
        defined($strErrorSeverity) && $strErrorSeverity eq ERROR_SEVERITY_FATAL)
    {
        $strState = STATE_ERROR;
    }
    else
    {
        $strState = STATE_OK;
    }

    my $strSessionKey = "${strUserName}:${strProcessId}:${strSessionId}:${strSessionStartTime}";

    # Lookup session key in the hash
    if (defined($oSessionHash{$strSessionKey}))
    {
        $oSessionHash{$strSessionKey}{last_log} = time();
        return $oSessionHash{$strSessionKey}{id};
    }

    # Attempt to select from database
    $hSqlSessionSelect->execute($strProcessId, $strSessionId, $strSessionStartTime);

    my ($lSessionId, $strDbUserName, $strDbDatabaseName, $strDbConnectionFrom, $strDbState) = $hSqlSessionSelect->fetchrow_array();

    # If the user name has changed then update the session log
    if (defined($lSessionId) &&
        ($strUserName ne $strDbUserName || $strDatabaseName ne $strDbDatabaseName || $strConnectionFrom ne $strDbConnectionFrom ||
         $strState ne $strDbState))
    {
        $hSqlSessionUpdate->execute($strUserName, $strDatabaseName, $strConnectionFrom, $strState, $lSessionId);
        $hDb->commit();
        print "session update =  " . $strSessionKey . "\n";
    }

    # If session not found in the db then insert it
    if (!defined($lSessionId))
    {
        $hSqlSessionInsert->execute($strUserName, $strProcessId, $strSessionId, $strSessionStartTime, $strDatabaseName,
                                    $strConnectionFrom, $strState);

        ($lSessionId) = $hSqlSessionInsert->fetchrow_array();
        $hDb->commit();
        print "session insert =  " . $strSessionKey . "\n";
    }

    # Add to the local cache
    $oSessionHash{$strSessionKey}{id} = $lSessionId;
    $oSessionHash{$strSessionKey}{last_log} = time();

    return $lSessionId;
}

####################################################################################################################################
# logWrite
####################################################################################################################################


####################################################################################################################################
# Main loop
####################################################################################################################################
# Open the ini file for reading
my $hFile;

print "opening $ARGV[0]\n";

if (!defined($ARGV[0]))
{
    confess "file to parse must be passed";
}

# Read updating file
# http://stackoverflow.com/questions/1425223/how-do-i-read-a-file-which-is-constantly-updating

open($hFile, '<', $ARGV[0])
    or confess "unable to open $ARGV[0]";

# Read the log file
my $oCSV = new PgAudit::CSV({binary => 1, empty_is_undef => 1});

while (my $stryRow = $oCSV->getline($hFile))
{
    my $lSessionId = sessionGet($$stryRow[LOG_FIELD_USER_NAME], $$stryRow[LOG_FIELD_PROCESS_ID],
                                $$stryRow[LOG_FIELD_SESSION_ID], $$stryRow[LOG_FIELD_SESSION_START_TIME],
                                $$stryRow[LOG_FIELD_DATABASE_NAME], $$stryRow[LOG_FIELD_CONNECTION_FROM],
                                $$stryRow[LOG_FIELD_COMMAND_TAG], $$stryRow[LOG_FIELD_ERROR_SEVERITY]);
}

if ($!)
{
    confess $!;
}

close($hFile);
